import { type Pushable } from 'it-pushable';
import { type FrameHeader } from './frame.js';
import type { Config } from './config.js';
import type { Stream, StreamStat } from '@libp2p/interface-connection';
import type { Logger } from '@libp2p/logger';
import type { Sink, Source } from 'it-stream-types';
import type { Uint8ArrayList } from 'uint8arraylist';
export declare enum StreamState {
    Init = 0,
    SYNSent = 1,
    SYNReceived = 2,
    Established = 3,
    Finished = 4
}
export declare enum HalfStreamState {
    Open = 0,
    Closed = 1,
    Reset = 2
}
export interface YamuxStreamInit {
    id: number;
    name?: string;
    sendFrame: (header: FrameHeader, body?: Uint8Array) => void;
    onStreamEnd: () => void;
    getRTT: () => number;
    config: Config;
    state: StreamState;
    log?: Logger;
    direction: 'inbound' | 'outbound';
}
/** YamuxStream is used to represent a logical stream within a session */
export declare class YamuxStream implements Stream {
    id: string;
    name?: string;
    stat: StreamStat;
    metadata: Record<string, any>;
    state: StreamState;
    /** Used to track received FIN/RST */
    readState: HalfStreamState;
    /** Used to track sent FIN/RST */
    writeState: HalfStreamState;
    /** Input to the read side of the stream */
    sourceInput: Pushable<Uint8ArrayList>;
    /** Read side of the stream */
    source: AsyncGenerator<Uint8ArrayList>;
    /** Write side of the stream */
    sink: Sink<Source<Uint8ArrayList | Uint8Array>, Promise<void>>;
    private readonly config;
    private readonly log?;
    private readonly _id;
    /** The number of available bytes to send */
    private sendWindowCapacity;
    /** Callback to notify that the sendWindowCapacity has been updated */
    private sendWindowCapacityUpdate?;
    /** The number of bytes available to receive in a full window */
    private recvWindow;
    /** The number of available bytes to receive */
    private recvWindowCapacity;
    /**
     * An 'epoch' is the time it takes to process and read data
     *
     * Used in conjunction with RTT to determine whether to increase the recvWindow
     */
    private epochStart;
    private readonly getRTT;
    /** Used to stop the sink */
    private readonly abortController;
    private readonly sendFrame;
    private readonly onStreamEnd;
    constructor(init: YamuxStreamInit);
    private createSource;
    close(): void;
    closeRead(): void;
    closeWrite(): void;
    abort(err?: Error): void;
    reset(): void;
    /**
     * Called when initiating and receiving a stream reset
     */
    private onReset;
    /**
     * Wait for the send window to be non-zero
     *
     * Will throw with ERR_STREAM_ABORT if the stream gets aborted
     */
    waitForSendWindowCapacity(): Promise<void>;
    /**
     * handleWindowUpdate is called when the stream receives a window update frame
     */
    handleWindowUpdate(header: FrameHeader): void;
    /**
     * handleData is called when the stream receives a data frame
     */
    handleData(header: FrameHeader, readData: () => Promise<Uint8ArrayList>): Promise<void>;
    /**
     * processFlags is used to update the state of the stream based on set flags, if any.
     */
    private processFlags;
    /**
     * finish sets the state and triggers eventual garbage collection of the stream
     */
    private finish;
    /**
     * getSendFlags determines any flags that are appropriate
     * based on the current stream state.
     *
     * The state is updated as a side-effect.
     */
    private getSendFlags;
    /**
     * potentially sends a window update enabling further writes to take place.
     */
    sendWindowUpdate(): void;
    private sendData;
    private sendClose;
    private sendReset;
}
//# sourceMappingURL=stream.d.ts.map