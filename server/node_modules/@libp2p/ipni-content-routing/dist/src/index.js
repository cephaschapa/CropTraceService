import { CodeError } from '@libp2p/interfaces/errors';
import { logger } from '@libp2p/logger';
import { peerIdFromString } from '@libp2p/peer-id';
import { multiaddr } from '@multiformats/multiaddr';
import { anySignal } from 'any-signal';
import toIt from 'browser-readablestream-to-it';
// @ts-expect-error no types
import ndjson from 'iterable-ndjson';
import defer from 'p-defer';
import PQueue from 'p-queue';
const log = logger('ipni-content-routing');
const defaultValues = {
    concurrentRequests: 4,
    timeout: 30e3
};
/**
 * An implementation of content routing, using a delegated peer
 */
class IpniContentRouting {
    started;
    httpQueue;
    shutDownController;
    clientUrl;
    timeout;
    /**
     * Create a new DelegatedContentRouting instance
     */
    constructor(url, init = {}) {
        log('enabled IPNI routing via', url);
        this.started = false;
        this.shutDownController = new AbortController();
        this.httpQueue = new PQueue({
            concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests
        });
        this.clientUrl = url instanceof URL ? url : new URL(url);
        this.timeout = init.timeout ?? defaultValues.timeout;
    }
    isStarted() {
        return this.started;
    }
    start() {
        this.started = true;
    }
    stop() {
        this.httpQueue.clear();
        this.shutDownController.abort();
        this.started = false;
    }
    async *findProviders(key, options = {}) {
        log('findProviders starts: %c', key);
        const signal = anySignal([this.shutDownController.signal, options.signal, AbortSignal.timeout(this.timeout)]);
        const onStart = defer();
        const onFinish = defer();
        void this.httpQueue.add(async () => {
            onStart.resolve();
            return onFinish.promise;
        });
        try {
            await onStart.promise;
            const resource = `${this.clientUrl}cid/${key.toString()}?cascade=ipfs-dht`;
            const getOptions = { headers: { Accept: 'application/x-ndjson' }, signal };
            const a = await fetch(resource, getOptions);
            if (a.body == null) {
                throw new CodeError('IPNI response had no body', 'ERR_BAD_RESPONSE');
            }
            for await (const event of ndjson(toIt(a.body))) {
                if (event.Metadata !== 'gBI=') {
                    continue;
                }
                yield this.mapEvent(event);
            }
        }
        catch (err) {
            log.error('findProviders errored:', err);
        }
        finally {
            signal.clear();
            onFinish.resolve();
            log('findProviders finished: %c', key);
        }
    }
    mapEvent(event) {
        const peer = peerIdFromString(event.Provider.ID);
        const ma = [];
        for (const strAddr of event.Provider.Addrs) {
            const addr = multiaddr(strAddr);
            ma.push(addr);
        }
        const pi = {
            id: peer,
            multiaddrs: ma,
            protocols: []
        };
        return pi;
    }
    async provide() {
        // noop
    }
    async put() {
        // noop
    }
    async get() {
        throw new CodeError('Not found', 'ERR_NOT_FOUND');
    }
}
export function ipniContentRouting(url, init = {}) {
    return () => new IpniContentRouting(url, init);
}
//# sourceMappingURL=index.js.map