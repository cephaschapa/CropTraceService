import { AbstractStream } from '@libp2p/interface-stream-muxer/stream';
import { CodeError } from '@libp2p/interfaces/errors';
import { logger } from '@libp2p/logger';
import * as lengthPrefixed from 'it-length-prefixed';
import { pushable } from 'it-pushable';
import { pEvent, TimeoutError } from 'p-event';
import { Uint8ArrayList } from 'uint8arraylist';
import { Message } from './pb/message.js';
const log = logger('libp2p:webrtc:stream');
// Max message size that can be sent to the DataChannel
const MAX_MESSAGE_SIZE = 16 * 1024;
// How much can be buffered to the DataChannel at once
const MAX_BUFFERED_AMOUNT = 16 * 1024 * 1024;
// How long time we wait for the 'bufferedamountlow' event to be emitted
const BUFFERED_AMOUNT_LOW_TIMEOUT = 30 * 1000;
// protobuf field definition overhead
const PROTOBUF_OVERHEAD = 3;
class WebRTCStream extends AbstractStream {
    /**
     * The data channel used to send and receive data
     */
    channel;
    /**
     * Data channel options
     */
    dataChannelOptions;
    /**
     * push data from the underlying datachannel to the length prefix decoder
     * and then the protobuf decoder.
     */
    incomingData;
    messageQueue;
    constructor(init) {
        super(init);
        this.channel = init.channel;
        this.channel.binaryType = 'arraybuffer';
        this.incomingData = pushable();
        this.messageQueue = new Uint8ArrayList();
        this.dataChannelOptions = {
            bufferedAmountLowEventTimeout: init.dataChannelOptions?.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT,
            maxBufferedAmount: init.dataChannelOptions?.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT,
            maxMessageSize: init.dataChannelOptions?.maxMessageSize ?? MAX_MESSAGE_SIZE
        };
        // set up initial state
        switch (this.channel.readyState) {
            case 'open':
                break;
            case 'closed':
            case 'closing':
                if (this.stat.timeline.close === undefined || this.stat.timeline.close === 0) {
                    this.stat.timeline.close = Date.now();
                }
                break;
            case 'connecting':
                // noop
                break;
            default:
                log.error('unknown datachannel state %s', this.channel.readyState);
                throw new CodeError('Unknown datachannel state', 'ERR_INVALID_STATE');
        }
        // handle RTCDataChannel events
        this.channel.onopen = (_evt) => {
            this.stat.timeline.open = new Date().getTime();
            if (this.messageQueue != null) {
                // send any queued messages
                this._sendMessage(this.messageQueue)
                    .catch(err => {
                    this.abort(err);
                });
                this.messageQueue = undefined;
            }
        };
        this.channel.onclose = (_evt) => {
            this.close();
        };
        this.channel.onerror = (evt) => {
            const err = evt.error;
            this.abort(err);
        };
        const self = this;
        this.channel.onmessage = async (event) => {
            const { data } = event;
            if (data === null || data.byteLength === 0) {
                return;
            }
            this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
        };
        // pipe framed protobuf messages through a length prefixed decoder, and
        // surface data from the `Message.message` field through a source.
        Promise.resolve().then(async () => {
            for await (const buf of lengthPrefixed.decode(this.incomingData)) {
                const message = self.processIncomingProtobuf(buf.subarray());
                if (message != null) {
                    self.sourcePush(new Uint8ArrayList(message));
                }
            }
        })
            .catch(err => {
            log.error('error processing incoming data channel messages', err);
        });
    }
    sendNewStream() {
        // opening new streams is handled by WebRTC so this is a noop
    }
    async _sendMessage(data, checkBuffer = true) {
        if (checkBuffer && this.channel.bufferedAmount > this.dataChannelOptions.maxBufferedAmount) {
            try {
                await pEvent(this.channel, 'bufferedamountlow', { timeout: this.dataChannelOptions.bufferedAmountLowEventTimeout });
            }
            catch (err) {
                if (err instanceof TimeoutError) {
                    this.abort(err);
                    throw new Error('Timed out waiting for DataChannel buffer to clear');
                }
                throw err;
            }
        }
        if (this.channel.readyState === 'closed' || this.channel.readyState === 'closing') {
            throw new CodeError('Invalid datachannel state - closed or closing', 'ERR_INVALID_STATE');
        }
        if (this.channel.readyState === 'open') {
            // send message without copying data
            for (const buf of data) {
                this.channel.send(buf);
            }
        }
        else if (this.channel.readyState === 'connecting') {
            // queue message for when we are open
            if (this.messageQueue == null) {
                this.messageQueue = new Uint8ArrayList();
            }
            this.messageQueue.append(data);
        }
        else {
            log.error('unknown datachannel state %s', this.channel.readyState);
            throw new CodeError('Unknown datachannel state', 'ERR_INVALID_STATE');
        }
    }
    async sendData(data) {
        const msgbuf = Message.encode({ message: data.subarray() });
        const sendbuf = lengthPrefixed.encode.single(msgbuf);
        await this._sendMessage(sendbuf);
    }
    async sendReset() {
        await this._sendFlag(Message.Flag.RESET);
    }
    async sendCloseWrite() {
        await this._sendFlag(Message.Flag.FIN);
    }
    async sendCloseRead() {
        await this._sendFlag(Message.Flag.STOP_SENDING);
    }
    /**
     * Handle incoming
     */
    processIncomingProtobuf(buffer) {
        const message = Message.decode(buffer);
        if (message.flag !== undefined) {
            if (message.flag === Message.Flag.FIN) {
                // We should expect no more data from the remote, stop reading
                this.incomingData.end();
                this.closeRead();
            }
            if (message.flag === Message.Flag.RESET) {
                // Stop reading and writing to the stream immediately
                this.reset();
            }
            if (message.flag === Message.Flag.STOP_SENDING) {
                // The remote has stopped reading
                this.closeWrite();
            }
        }
        return message.message;
    }
    async _sendFlag(flag) {
        log.trace('Sending flag: %s', flag.toString());
        const msgbuf = Message.encode({ flag });
        const prefixedBuf = lengthPrefixed.encode.single(msgbuf);
        await this._sendMessage(prefixedBuf, false);
    }
}
export function createStream(options) {
    const { channel, direction, onEnd, dataChannelOptions } = options;
    return new WebRTCStream({
        id: direction === 'inbound' ? (`i${channel.id}`) : `r${channel.id}`,
        direction,
        maxDataSize: (dataChannelOptions?.maxMessageSize ?? MAX_MESSAGE_SIZE) - PROTOBUF_OVERHEAD,
        dataChannelOptions,
        onEnd,
        channel
    });
}
//# sourceMappingURL=stream.js.map