import { createStream } from './stream.js';
import { nopSink, nopSource } from './util.js';
const PROTOCOL = '/webrtc';
export class DataChannelMuxerFactory {
    protocol;
    /**
     * WebRTC Peer Connection
     */
    peerConnection;
    streamBuffer = [];
    metrics;
    dataChannelOptions;
    constructor(init) {
        this.peerConnection = init.peerConnection;
        this.metrics = init.metrics;
        this.protocol = init.protocol ?? PROTOCOL;
        this.dataChannelOptions = init.dataChannelOptions;
        // store any datachannels opened before upgrade has been completed
        this.peerConnection.ondatachannel = ({ channel }) => {
            const stream = createStream({
                channel,
                direction: 'inbound',
                dataChannelOptions: init.dataChannelOptions,
                onEnd: () => {
                    this.streamBuffer = this.streamBuffer.filter(s => s.id !== stream.id);
                }
            });
            this.streamBuffer.push(stream);
        };
    }
    createStreamMuxer(init) {
        return new DataChannelMuxer({
            ...init,
            peerConnection: this.peerConnection,
            dataChannelOptions: this.dataChannelOptions,
            metrics: this.metrics,
            streams: this.streamBuffer,
            protocol: this.protocol
        });
    }
}
/**
 * A libp2p data channel stream muxer
 */
export class DataChannelMuxer {
    init;
    /**
     * Array of streams in the data channel
     */
    streams;
    protocol;
    peerConnection;
    dataChannelOptions;
    metrics;
    /**
     * Close or abort all tracked streams and stop the muxer
     */
    close = () => { };
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    source = nopSource();
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    sink = nopSink;
    constructor(init) {
        this.init = init;
        this.streams = init.streams;
        this.peerConnection = init.peerConnection;
        this.protocol = init.protocol ?? PROTOCOL;
        this.metrics = init.metrics;
        /**
         * Fired when a data channel has been added to the connection has been
         * added by the remote peer.
         *
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/datachannel_event}
         */
        this.peerConnection.ondatachannel = ({ channel }) => {
            const stream = createStream({
                channel,
                direction: 'inbound',
                dataChannelOptions: this.dataChannelOptions,
                onEnd: () => {
                    this.streams = this.streams.filter(s => s.id !== stream.id);
                    this.metrics?.increment({ stream_end: true });
                    init?.onStreamEnd?.(stream);
                }
            });
            this.streams.push(stream);
            if ((init?.onIncomingStream) != null) {
                this.metrics?.increment({ incoming_stream: true });
                init.onIncomingStream(stream);
            }
        };
        const onIncomingStream = init?.onIncomingStream;
        if (onIncomingStream != null) {
            this.streams.forEach(s => { onIncomingStream(s); });
        }
    }
    newStream() {
        // The spec says the label SHOULD be an empty string: https://github.com/libp2p/specs/blob/master/webrtc/README.md#rtcdatachannel-label
        const channel = this.peerConnection.createDataChannel('');
        const stream = createStream({
            channel,
            direction: 'outbound',
            dataChannelOptions: this.dataChannelOptions,
            onEnd: () => {
                this.streams = this.streams.filter(s => s.id !== stream.id);
                this.metrics?.increment({ stream_end: true });
                this.init?.onStreamEnd?.(stream);
            }
        });
        this.streams.push(stream);
        this.metrics?.increment({ outgoing_stream: true });
        return stream;
    }
}
//# sourceMappingURL=muxer.js.map