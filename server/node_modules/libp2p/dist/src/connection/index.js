import { symbol } from '@libp2p/interface-connection';
import { OPEN, CLOSING, CLOSED } from '@libp2p/interface-connection/status';
import { CodeError } from '@libp2p/interfaces/errors';
import { logger } from '@libp2p/logger';
const log = logger('libp2p:connection');
/**
 * An implementation of the js-libp2p connection.
 * Any libp2p transport should use an upgrader to return this connection.
 */
export class ConnectionImpl {
    /**
     * Connection identifier.
     */
    id;
    /**
     * Observed multiaddr of the remote peer
     */
    remoteAddr;
    /**
     * Remote peer id
     */
    remotePeer;
    /**
     * Connection metadata
     */
    stat;
    /**
     * User provided tags
     *
     */
    tags;
    /**
     * Reference to the new stream function of the multiplexer
     */
    _newStream;
    /**
     * Reference to the close function of the raw connection
     */
    _close;
    /**
     * Reference to the getStreams function of the muxer
     */
    _getStreams;
    _closing;
    /**
     * An implementation of the js-libp2p connection.
     * Any libp2p transport should use an upgrader to return this connection.
     */
    constructor(init) {
        const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init;
        this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`;
        this.remoteAddr = remoteAddr;
        this.remotePeer = remotePeer;
        this.stat = {
            ...stat,
            status: OPEN
        };
        this._newStream = newStream;
        this._close = close;
        this._getStreams = getStreams;
        this.tags = [];
        this._closing = false;
    }
    [Symbol.toStringTag] = 'Connection';
    [symbol] = true;
    /**
     * Get all the streams of the muxer
     */
    get streams() {
        return this._getStreams();
    }
    /**
     * Create a new stream from this connection
     */
    async newStream(protocols, options) {
        if (this.stat.status === CLOSING) {
            throw new CodeError('the connection is being closed', 'ERR_CONNECTION_BEING_CLOSED');
        }
        if (this.stat.status === CLOSED) {
            throw new CodeError('the connection is closed', 'ERR_CONNECTION_CLOSED');
        }
        if (!Array.isArray(protocols)) {
            protocols = [protocols];
        }
        const stream = await this._newStream(protocols, options);
        stream.stat.direction = 'outbound';
        return stream;
    }
    /**
     * Add a stream when it is opened to the registry
     */
    addStream(stream) {
        stream.stat.direction = 'inbound';
    }
    /**
     * Remove stream registry after it is closed
     */
    removeStream(id) {
    }
    /**
     * Close the connection
     */
    async close() {
        if (this.stat.status === CLOSED || this._closing) {
            return;
        }
        this.stat.status = CLOSING;
        // close all streams - this can throw if we're not multiplexed
        try {
            this.streams.forEach(s => { s.close(); });
        }
        catch (err) {
            log.error(err);
        }
        // Close raw connection
        this._closing = true;
        await this._close();
        this._closing = false;
        this.stat.timeline.close = Date.now();
        this.stat.status = CLOSED;
    }
}
export function createConnection(init) {
    return new ConnectionImpl(init);
}
//# sourceMappingURL=index.js.map