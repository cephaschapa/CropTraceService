import { setMaxListeners } from 'events';
import { randomBytes } from '@libp2p/crypto';
import { CodeError } from '@libp2p/interfaces/errors';
import { logger } from '@libp2p/logger';
import { abortableDuplex } from 'abortable-iterator';
import { anySignal } from 'any-signal';
import first from 'it-first';
import { pipe } from 'it-pipe';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import { codes } from '../errors.js';
import { PROTOCOL_PREFIX, PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION, TIMEOUT, MAX_INBOUND_STREAMS, MAX_OUTBOUND_STREAMS } from './constants.js';
const log = logger('libp2p:ping');
class DefaultPingService {
    protocol;
    components;
    started;
    timeout;
    maxInboundStreams;
    maxOutboundStreams;
    constructor(components, init) {
        this.components = components;
        this.started = false;
        this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
        this.timeout = init.timeout ?? TIMEOUT;
        this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
        this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    }
    async start() {
        await this.components.registrar.handle(this.protocol, this.handleMessage, {
            maxInboundStreams: this.maxInboundStreams,
            maxOutboundStreams: this.maxOutboundStreams
        });
        this.started = true;
    }
    async stop() {
        await this.components.registrar.unhandle(this.protocol);
        this.started = false;
    }
    isStarted() {
        return this.started;
    }
    /**
     * A handler to register with Libp2p to process ping messages
     */
    handleMessage(data) {
        const { stream } = data;
        void pipe(stream, stream)
            .catch(err => {
            log.error(err);
        });
    }
    /**
     * Ping a given peer and wait for its response, getting the operation latency.
     *
     * @param {PeerId|Multiaddr} peer
     * @returns {Promise<number>}
     */
    async ping(peer, options = {}) {
        log('dialing %s to %p', this.protocol, peer);
        const start = Date.now();
        const data = randomBytes(PING_LENGTH);
        const connection = await this.components.connectionManager.openConnection(peer, options);
        let stream;
        const signal = anySignal([AbortSignal.timeout(this.timeout), options?.signal]);
        try {
            // fails on node < 15.4
            setMaxListeners?.(Infinity, signal);
        }
        catch { }
        try {
            stream = await connection.newStream([this.protocol], {
                signal
            });
            // make stream abortable
            const source = abortableDuplex(stream, signal);
            const result = await pipe([data], source, async (source) => first(source));
            const end = Date.now();
            if (result == null || !uint8ArrayEquals(data, result.subarray())) {
                throw new CodeError('Received wrong ping ack', codes.ERR_WRONG_PING_ACK);
            }
            return end - start;
        }
        finally {
            if (stream != null) {
                stream.close();
            }
            signal.clear();
        }
    }
}
export function pingService(init = {}) {
    return (components) => new DefaultPingService(components, init);
}
//# sourceMappingURL=index.js.map