import filter from 'it-filter';
import forEach from 'it-foreach';
import { CustomProgressEvent } from 'progress-events';
/**
 * Networked storage wraps a regular blockstore - when getting blocks if the
 * blocks are not present Bitswap will be used to fetch them from network peers.
 */
export class NetworkedStorage {
    child;
    bitswap;
    /**
     * Create a new BlockStorage
     */
    constructor(blockstore, options = {}) {
        this.child = blockstore;
        this.bitswap = options.bitswap;
    }
    unwrap() {
        return this.child;
    }
    /**
     * Put a block to the underlying datastore
     */
    async put(cid, block, options = {}) {
        if (await this.child.has(cid)) {
            options.onProgress?.(new CustomProgressEvent('blocks:put:duplicate', cid));
            return cid;
        }
        if (this.bitswap?.isStarted() === true) {
            options.onProgress?.(new CustomProgressEvent('blocks:put:bitswap:notify', cid));
            this.bitswap.notify(cid, block, options);
        }
        options.onProgress?.(new CustomProgressEvent('blocks:put:blockstore:put', cid));
        return this.child.put(cid, block, options);
    }
    /**
     * Put a multiple blocks to the underlying datastore
     */
    async *putMany(blocks, options = {}) {
        const missingBlocks = filter(blocks, async ({ cid }) => {
            const has = await this.child.has(cid);
            if (has) {
                options.onProgress?.(new CustomProgressEvent('blocks:put-many:duplicate', cid));
            }
            return !has;
        });
        const notifyEach = forEach(missingBlocks, ({ cid, block }) => {
            options.onProgress?.(new CustomProgressEvent('blocks:put-many:bitswap:notify', cid));
            this.bitswap?.notify(cid, block, options);
        });
        options.onProgress?.(new CustomProgressEvent('blocks:put-many:blockstore:put-many'));
        yield* this.child.putMany(notifyEach, options);
    }
    /**
     * Get a block by cid
     */
    async get(cid, options = {}) {
        if (options.offline !== true && this.bitswap?.isStarted() != null && !(await this.child.has(cid))) {
            options.onProgress?.(new CustomProgressEvent('blocks:get:bitswap:get', cid));
            const block = await this.bitswap.want(cid, options);
            options.onProgress?.(new CustomProgressEvent('blocks:get:blockstore:put', cid));
            await this.child.put(cid, block, options);
            return block;
        }
        options.onProgress?.(new CustomProgressEvent('blocks:get:blockstore:get', cid));
        return this.child.get(cid, options);
    }
    /**
     * Get multiple blocks back from an (async) iterable of cids
     */
    async *getMany(cids, options = {}) {
        options.onProgress?.(new CustomProgressEvent('blocks:get-many:blockstore:get-many'));
        yield* this.child.getMany(forEach(cids, async (cid) => {
            if (options.offline !== true && this.bitswap?.isStarted() === true && !(await this.child.has(cid))) {
                options.onProgress?.(new CustomProgressEvent('blocks:get-many:bitswap:get', cid));
                const block = await this.bitswap.want(cid, options);
                options.onProgress?.(new CustomProgressEvent('blocks:get-many:blockstore:put', cid));
                await this.child.put(cid, block, options);
            }
        }));
    }
    /**
     * Delete a block from the blockstore
     */
    async delete(cid, options = {}) {
        options.onProgress?.(new CustomProgressEvent('blocks:delete:blockstore:delete', cid));
        await this.child.delete(cid, options);
    }
    /**
     * Delete multiple blocks from the blockstore
     */
    async *deleteMany(cids, options = {}) {
        options.onProgress?.(new CustomProgressEvent('blocks:delete-many:blockstore:delete-many'));
        yield* this.child.deleteMany((async function* () {
            for await (const cid of cids) {
                yield cid;
            }
        }()), options);
    }
    async has(cid, options = {}) {
        return this.child.has(cid, options);
    }
    async *getAll(options = {}) {
        options.onProgress?.(new CustomProgressEvent('blocks:get-all:blockstore:get-many'));
        yield* this.child.getAll(options);
    }
}
//# sourceMappingURL=networked-storage.js.map